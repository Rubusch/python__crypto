#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
#
# @author: Lothar Rubusch
# @email: L.Rubusch@gmx.ch
# @license: GPLv3
# @2014-Feb-28

# implementation of a stream cipher, based on a linear feedback shift register
# (LFSR, as a PRNG - here just a static coefficient list and formula)
#
#
# USAGE
# $ ./LFSR-stream-cipher.py <input word, no spaces>

import sys


# list of feedback coeffs for encrypt / decrypt - this is generated by LFSR normally
feedback_coefficients = [1,0,0,1,1,1]

# allowed characters
abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ012345"

# translation
alpha2bin = {}
bin2alpha = {}

## exit
def die(msg):
    if 0 < len(msg): print(msg)
    sys.exit(1)


## init bit
def bitinit(): return "0"


## adds to a single bit, returns: (val, carry)
def bitadd(bit,add):
    b=int(bit)
    a=int(add)
    if (b+a)%2 == 0: return ("0","1")
    return ("1","0")


## compare to '0'
def bitisnull(bit):
    if bit=="0": return True
    return False


## inits dictionary
## each char is represented by 5 bit
def initdict():
    nbits = 5

    ## set base pointer
    base = ""
    for n in range(nbits):
        base += "0"

    ## set dict
    for c in abc:
        val = base
        if c != 'A':
            ## increment if not A, which is 'b0"
            val = [b for b in base]
            offset = [i for i in abc].index(c)
            for inc in range(offset):

                ## per incrementation, take care of the carry
                pos = len(val) -1
                carry = bitinit()
                while(True):
                    if bitisnull(carry): carry="1" # once first
                    (val[pos],carry) = bitadd(val[pos],carry)
                    if bitisnull(carry): break
                    else: pos -= 1

        alpha2bin.update({c:val})
        bin2alpha.update({"".join(val):c})


## returns ciphertext or plaintext - since it is a symmetric cipher and works on
## mod 2 the theoretic '-' and '+' operations are equal
def encryptdecrypt(binplaintext):
    m = len(feedback_coefficients)
    m_idx = 0
    binciphertext=[]
    for c in binplaintext:
        (ciphbit,dummy) = bitadd(c, feedback_coefficients[m_idx%m])
        binciphertext.append(ciphbit)
        m_idx+=1
    return binciphertext


## printer function
def print_alpha(binplaintext):
    cnt=0
    val=[]
    for c in binplaintext:
        cnt+=1
        val.append(c)
        if cnt%5 == 0:
            print(bin2alpha.get("".join(val)))
            val=[]


## args - the filenmae
def main(argv=sys.argv[1:]):
    ## shall result in "ABC"
    plaintext = "TY4"
    if len(argv) > 0: plaintext = argv[0]
    plaintext = plaintext.upper()
    print(f"provided input: {plaintext}")

    ## init dictionary
    initdict()
    binplaintext = []
    for c in plaintext:
        try:
            binplaintext += alpha2bin.get(c)
        except TypeError:
            die("FAIL: only letters and no spaces allowed in input")

    binciphertext = encryptdecrypt(binplaintext)

    print_alpha(binciphertext)


### start ###
if __name__ == '__main__':
    main()

print("READY.")
